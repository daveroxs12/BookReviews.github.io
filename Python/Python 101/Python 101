Chapter 2 - All About Strings

Strings: Can be created with single quotes '', double quotes(""), or triple quotes, for multi-line files(''' ''')
  Type: Immutable types.
  Reassigning a string: Any time a string in python is reassiged its identity changes.
  
  Containts: Only ASCII Characters, if want to use Unicode characters, must be preceded by a u.

Casting: Transforming one type into another type(E.g, x = str(1))

String Formatting: %s, to format strings (E.g, 'I Lke %s' % (NY))
%i (E.G, ('%i + %i = %i' % (1,2,3)

%f - Format floats (E.G, ('%.4f and %.4f) % (.23, .23333).

Templates: ('%(lang)s is equivalent to' {'lang','david'})

('%(lang)s and %(lang)s and %(lang)s and %(lang)s' % {'lang':'david'}
  //Returns david and david and david and david
  
 Chapter 3 - Lists, Tuples, and Dictionaries:
  
  Lists: Create a Lists with (my_list = list(), my_list = []), including a mixutre of objects.
  
  Nested Lits: Nested lists are lists within lists (E.g, mylist = [['a']['b']
  
  Extend Method: The extend method consolidates two lists together. (E.g, list2.extend(list3))
    list2 += list3
    
   Sort: The sort() method of a list 
   
   Tuples: 
   my_tuple = (0, 1, 2, 3, 4, 5)
   abc = tuple([1, ,2, 3, ,4, 5])
   
 Chapter 4- Conditional Statements:
 
 New Line Character \n
 Tab Character: \t
 
 if __name__ == '__main__':
  Only run the code if the file is executed as a standalone file.
  
  Chapter 5- Loops:
  Loops are used to repeat an action a set number of times. (For, while).
  
  Range: The range(5, 10) will return the numbers from 5, up to, but not including ten.
  
  Range(5, 10, 2) Returns every second value between 5 and 10(9), is referred to as the 'step-value.'
  
  Dictionaries and For Loops: 
  a_dict = {'one':1, 'two':2}
  for key in a_dict:
    print(key)
    //Returns two, one, because dictionaries are unordered.
    
    The sort(keys) will sort the keys
    keys = sorted(a_dict.keys())
    
  Break: The break within functions is a FLOW CONTROL TOOL, terminates the current loop, and resumes executiion at the next statement.
  
  Continue: Skips over a specific loop.
  
  Chapter 6- Lists Comprehensions:
  
  [x for x in range(0, 10 ,2)]
  
  strip(): The strip() method removes leading/ending white space.
  
  Nested List Comprehension:
  nested_list = [ [1, 2, 3] [4, 5, 6] [7, 8, 9]]
  [num for elem in nested_list for num in elem]
  
  Dictionary Comprehensions:
  
  print( {i: str(i) for i in range(5)} )
  
  A Set Comprehension: A set comprehension is a list comprehension that removes duplicates.
  mylist = []
  my_set = set(myList) or {x for x in myList}
  
  Chapter 7 - Exception Handling:
  
  Handle Exceptions: Use try: except IOError: in Python.
  
  Bare Except: A bare except catches any and all exceptions in Python (E.g, try: except), not recommended b/c do not know what exception you are attempting
  to catch.
  
  Multiple exceptions: try: except (KeyError, IndexError): or except KeyError: except indexError.
  
  Finally: Will execute after except in Python
  
  Else: The else for exceptions, the else will only run if there are no errors raised.
  
  Chapter 8 - Working with Files:
  
  Open: Python has a built-in open file for reading.
  
  (E.g, open('Text.file','r')
  
  Read: The read() function is used to read text. Accepts arguments, 1024 reads 1024 kilobyes of the file.
  
  Readline: The readline() function is used to read one line.
  Readlines: The readlines() function read all of the lines.
  
  Reading Line by Line:
  For line in handle:
    print(line)
    
    Read Binary: To read binary change the file mode to 'rb', read binary.
    
  With open: The with open creates a context manager that will automatically close the file when you have finishd with it.
  
  Chapter 9 - Importing:
  
  import this
  
  from function import module
  (E.g, from math import sqrt, pi)
  
  Shadowing: Change the module to a variable
  
  Chapter 10 - Functions:
  
  pass: When the function is executed and pass is included, nothing occurs.
  
  Return: All functions return something, and if nothing is returned, None is returned
  
  **Args: **args for infinite arguments, and **kargs or infinite keyword arguments.
  
  Scope: Once a function ends, a varible is out-of-scope, and can no longer be used.
  
  Chapter 11 - Classes:
  
  Objects: Everything is Python is an object, or everything in Python has a methods and values. 
  
  __Init__: the __init__ method is the constructor in Python, and it is called when you instantiate an object based on a class.
  
  Method: A function changes its name to a method when it is within a class.
  
  if __name__ == '__main__':
    Run the code as a standalone file
   
    Chapter 12 - Introspection:
    
    Help: The help() module
    
  Chapter 13 - The CSV Module:
  
    CSV Module: import csv, and use the reader object to read.
    import csv
    csv.reader(fileName)
    
    DictReader:
    import csv
    reader = csv.DictReader(file_obj, delimiter='')
    for line in reader:
    print(line['first_name'])
    
 Chapter 14 - ConfigParser:
 
 Writing to a file with ConfigParser:
 
 import configparser as c
 config = c.ConfigParser()
 config.add_section('Name') //Creates one Section labeled Name with 2 options, fontype, font_size
 config.set('Settings','Fontype','Courier')
 config.set('Settings','font_size','Courier')
 
 with open('settings.ini','w') as config_file:
  config.write(config_file)
 
 Read Values from Config: config.get('Settings','Font')
 
 Remove an Option from ConfigParser:
  config.remove_option('Settings','Font Style')
 
 Chapter 15 - Logging:
 
 Logging: import logging:
 
           logging.basicConfig(filename = 'sample.log',level=logging.INFO)
          logging.debug('This is a debug message')
          logging.info('Informational Message')
          logging.error('An error has occurred')
          
          try: raise Runtime
          except runtimeError:
            log.exception('Error!')
            
 Chapter 16 - The OS Module:
 
 OS: Import the OS module (import os)
 
 Os.Name: Os.Name returns the name ofthe system.
 
 Os.environ: Os.environ() returns the environmental variables set by the computer ,such as, type of CPU, etc.
  Os.getenv('User') returns the environmental variable.
  
 Os.chdir: Os.chdir() allows one to change the directory that the current Python file is running in.
 
 Os.getcwd(): Os.getcwd() returns the current directory that the Python file is running in.
 
 Os.mkdir(): OS.mkdir('Test') creates a single folder:
 
 os.makedirs(): os.makedirs() will create all of the intermediate folder sif they don't exist.
 
 os.remove: OS.remove('file') removes a file.
 
 os.rmdir(): os.rmir('Dir') removes a directory.
 
 os.rename(): Os.rename(src, dst) renames a folder/file.
 
 os.startfile(): Os.startfile(r'FilePath') Starts a file
 
 path = ''
 for root, dirs in os.walk(path)
  print(path)
 Os.walk(): Using os.walk(), one can access all the root directories.
 
 OS.path(): Os.path() Finds the apth
  os.path.basename(path) returns the filename of a path.
  
  Chapter 17 - The Email/SMPTLib Module:
  
  Chapter 18: The SQLite Module:
  
  SQLLite Module: The SQLLite Module is a module for creating a SQL Database without importing any additional dependencies.
  
  #Import SQLLite3 Module
  import sqllite3
  
  #Create a Connection to the Datbase 
  conn = sqllite3.connect('databasename')
  
  #Import Cursor Object, Which allows one to add records and to interact with the databse.
  cursor = conn.cursor()
  
  #Create a Table
  cursor.execute('''CREATE TABLE albums (title text, artist text, release_date text, publisher text, media_type text)''')
  
  5 Supported Data Types of SQL: Null, Integer, Real, Text, and Blob.
  
  #Insert into the database
  
  cursor.execute('''INSERT INTO albums
  ('Glow','Andy Hunter','7/24/2012','Xplore Records','MP3')'''
  ''')
  
  #Save data into the database
  conn.commit()
  
  #Close Connection.
  
  #Add Multiple Values into the SQLite Databse:

  albums = [('Exodus', 'Andy Hunter', '7/9/2002', 'Sparrow Records', 'CD'),
  12 ('Until We Have Faces', 'Red', '2/1/2011', 'Essential Records', 'CD')]

  #Insert the Values into the Database
  cursor.executemany('INSERT INTO albums VALUES(?, ?', albums)

  #Commit the Data into the Table
  conn.commit()
  
  #Updating and Deleting Values:
  
  sql = '''
  UPDATE albums
  SET artist = 'John Doe'
  WHERE artist = 'Andy Hunter'
  '''
  
  #Execute the Data
  
  cursor.execute(sql)
  
  #Delete a SQL Value:
  
  sql = '''
    DELETE from albums
    WHERE artist = 'John Doe'
  '''
  '
  
  Chapter 21 - The Threading Module:
  
  Threading: Threading accomplishes concurrency, or accomplishing two tasks at once.
  
  Chapter 22 - Dates and Times:
  
  Datetime.date(Year, Month, Date)
  
  Today: datetime.date.today()
  
  Datetime.datei te: Datetime.datetime() passes the arguments of year, month, day, hour, minute, second.
  
  Strftime: Strftime('%Y%m%d') displays the time in amore readable format
  
  Timedetla: Datetime.timedelta() is the difference between two days or tines.
  
  Time Module: Time.ctime() will convert time into a time into seconds:
    (E.G, import time; time.ctime() 'Thu Mar 06 07:28:48 2014'
    >>> time.ctime(1384112639)
5 'Sun Nov 10 13:43:59 2013'

Time.sleep(): Time.sleep() delays the function or module for a specified period of time.
for x in range(5):
 time.sleep(2)
 print("Slept for 2 seconds")
 Prints the phrase five times with a two-second delay.
 
 time.strftime(): Time.strftime() time.strftime("%Y-%m-%d-%H.%M.%S",
2 time.localtime())

Time Time: Time.time() will return the time in seconds.

Chapter 23 - The XML Module:
  
  Minidom: 
  
  XML.getElementByTagName('David')
  
  Parsing with Element Tree: 
  
  How to Create XML with ElementTree:
  
  import xml.etree.ElementTree as xml
  
  def createXML(filename):
    root = xml.Element('zAppointments')
    appt = xml.Element('appointment')
    root.append(appt)
    
    #Add Appointment Children

    begin = xml.SubElement(appt, 'begin')
    begin.text = '1181251680'
    
    alarmTime = xml.SubElement(appt, "alarmTime")
   alarmTime.text = "1181572063"

   state = xml.SubElement(appt, "state")

   location = xml.SubElement(appt, "location")
   
   tree = xml.ElementTree(root)
    with open(filename, "w") as fh:
        tree.write(fh)
        
  Edit HTML with ElementTree:
    import xml.etree.cElementTree as ET
    
    def editXML(filename):
      tree = ET.ElementTree(file=filename)
      root = tree.getroot()

      for begin_time in root.iter('begin'):
          begin_time.text = time.ctime(int(begin_time.text))

      tree = ET.ElementTree(root)
      with open("updated.xml", "w") as f:
           tree.write(f)

if __name__ == "__main__":
     editXML("original_appt.xml")
     
  Parse XML with ElementTree: 
  
  def parseXML(xml_file):
    tree = ET.ElementTree(file=xml_file)
    print(tree.getroot())
    root = tree.getroot()
    print("tag=%s, attrib=%s" % (root.tag, root.attrib))
    for child in root:
        print(child.tag, child.attrib)
         if child.tag == 'appointment':
            for step_child in child:
                print(step_child.tag)
    #Iterate Over the Entire Tree:
    print('-' * 40)
    print('Iterating using a tree iterator')
    print('-' * 40)
    iter = tree.getiterator()
    for elem in iter:
        print(elem.tag)
        
    #Retrieve Information via the children!
    print('-' * 40)
    print('Iterating Using getChildren()')
    print('-' * 40)
    appointments = root.getchildren()
    for appt in appointments:
        appt_children = appt.getchildren()
        for appt_child in appt_children:
            print("%s=%s" % (appt_child.tag, appt_child.text))
            
     #Ctree: Ctree is much faster, because it runs on C.
  
 
